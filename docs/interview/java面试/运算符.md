##  运算符分类

| 优先级               | 运算符分类 | 结合顺序                                      | 运算符              |
| -------------------- | ---------- | --------------------------------------------- | ------------------- |
| 由高到低             | 分隔符     | 左结合                                        | .  []   ( )   ;   , |
| 一元运算符           | 右结合     | ! ++   --   -  ~                              |                     |
| 算术运算符移位运算符 | 左结合     | *   /   %  +   -   <<  >>  >>>                |                     |
| 关系运算符           | 左结合     | <   >   <=  >=  instanceof(Java 特有)  = = != |                     |
| 逻辑运算符           | 左结合     | ! && \|\| ~ & \| ^                            |                     |
| 三目运算符           | 右结合     | 布尔表达式?表达式1:表达式2                    |                     |
| 赋值运算符           | 右结合     | = *=   /= %=  +=  -=  <<= >>= >>>= &= *= \|=  |                     |



## 移位运算符

### 左移运算符（<<）

> 按二进制形式把所有的数字向左移动对应的位数，高位移出(舍弃)，低位的空位补0。

#### 正数

```java
例：12 << 2
1、首先转化为二进制，12的二进制为0000 1100
2、将二进制数向左移两位，低位补0，得到0011 0000
3、最后将二进制数转化成十进制数，0011 0000转化为十进制为48
所以，12 << 2 = 48
12345
```

#### 负数

负数的移位运算相对于正数来说就有些难度了，难度在哪里呢？
当然是`负数的二进制表示`及`十进制的转化`

```java
例：-12 << 2
1、首先转化为二进制，-12的二进制为1111 0100
2、将二进制数向左移两位，低位补0，得到1101 0000
3、最后将二进制数转化成十进制数，1101 0000转化为十进制为-48
所以，-12 << 2 = -48
12345
```

### 右移运算符（>>）

> 按二进制形式把所有的数字向右移动对应位移位数，低位移出(舍弃)，高位的空位补`符号位`，即正数补0，负数补1。

#### 正数

```java
例：20 >> 2
1、首先转化为二进制，20的二进制为0001 0100
2、将二进制数向右移两位，高位补符号位（0），得到0000 0101
3、最后将二进制数转化成十进制数，0000 0101转化为十进制为5
所以，20 >> 2 = 5
12345
```

#### 负数

```java
例：-20 >> 2
1、首先转化为二进制，20的二进制为1110 1100
2、将二进制数向右移两位，高位补符号位（1），得到1111 1011
3、最后将二进制数转化成十进制数，1111 1011转化为十进制为-5
所以，-20 >> 2 = -5
12345
```

### 无符号右移运算符（>>>）

> 按二进制形式把所有的数字向右移动对应位数，低位移出(舍弃)，`高位的空位补零`。对于正数来说和带符号右移（>>） 相同，但是对于负数来说不同。

#### 正数

```java
例：15 >>> 2
1、首先转化为二进制，15的二进制为0000 1111
2、将二进制数向右移两位，高位补0，得到0000 0011
3、最后将二进制数转化成十进制数，0000 0011转化为十进制为3
所以，15 >>> 2 = 3
12345
```

#### 负数

**因为负数的符号位（最高位）为1，而无符号右移要在最高位补0，`所以32位二进制要写全`。带符号右移（>>）,高位是补的符号位，前24位都是1(例子中的数比较小，8位足以表示；若是数字很大，要16位才能表示的话，那就是前16位都是1)，省略掉不影响计算；但这种情况比较特殊，补位和符号位不一样。**

```java
例：-15 >>> 2
1、首先转化为二进制，-15的二进制为1111 1111 1111 1111 1111 1111 1111 0001
2、将二进制数向右移两位，高位补0，得到0011 1111 1111 1111 1111 1111 1111 1100
3、最后将二进制数转化成十进制数，0011 1111 1111 1111 1111 1111 1111 1100转化为十进
制为1073741820
所以，-15 >>> 2 = 1073741820
123456
若有说的不对的地方，或是更好的方法，欢迎留言指教，共同学习
```

## 原码、反码、补码

**原码**
原码就是机器数，是加了一位符号位的二进制数(因为数值有正负之分)，正数符号位为0，负数符号位为1。

**反码**
带符号位的原码乘除运算时结果正确，而在加减运算的时候就出现了问题，比如: 用十进制表示:`1 + (-1) = 0`, 但用二进制表示:

00000001 + 10000001 = 10000010,

将结果换算成十进制数也就是 -2。于是在原码的基础上发明了反码,用来解决这种问题。

**补码**
虽然反码的出现解决了正负数的加减问题, 但却让0这个数字有了两种"形态": "0"和"-0", 但这是不合逻辑的,只应该有一个0,所以出现了补码。

**对于有符号数而言**：

> 1、正数的原码、反码、补码都一样；
> 2、负数的反码 = 它的原码符号位不变，其他位取反（取反的意思：0 换成 1 、 1 换成 0 ）；
> 3、负数的补码 = 它的反码 +1；
> 4、0的反码、补码都是0；
> **【特别注意】
> 1、在计算机运算的时候，都是以 补码 的方式来运算的 。
> 2、二进制 转为 十进制，必须使用 二进制 的原码进行转换 。**



## 与、或、非、异或

1.与运算（&）

进行运算的两个数据，按二进制位进行“与”运算。

规则：0&0=0;  0&1=0;  1&0=0;   1&1=1;    

即： 两位同时为“1”，结果才为“1”，否则为0

 

2.或运算（|）

 进行运算的两个数据，按二进制位进行“或”运算。

 运算规则：0|0=0；  0|1=1；  1|0=1；  1|1=1；

 即 ：参加运算的两个对象只要有一个为1，其值为1。

 

3.非运算：~

1取0，0取1 ~1 = 0, ~0 = 1 ~(10001) = 01110

 

4.异或运算（^）

 参加运算的两个数据，按二进制位进行“**异或**”运算。

  运算规则：0^0=0；  0^1=1；  1^0=1；  1^1=0；

 即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。