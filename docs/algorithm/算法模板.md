## 算法模板

```java
package com.li.exam.template;

import java.io.BufferedInputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.util.*;

class BinarySearch{

    // 最基本的二分查找:
    static int b(int[] arr, int key){
        int L = 0, R = arr.length - 1;
        while(L <= R){
            int mid = L + (R - L) / 2;
            if(arr[mid] == key) return mid;
            if(arr[mid] > key)
                R = mid - 1;
            else
                L = mid + 1;
        }
        return -1;
    }
    // 查找第一个=key的，不存在返回-1
    // 左边的三个， 注意是L < arr.length
    static int firstEqual(int[] arr, int key){
        int L = 0, R = arr.length - 1;
        while(L <= R){
            int mid = L + (R - L) / 2;
            if(arr[mid] >= key)
                R = mid - 1;
            else
                L = mid + 1;
        }
        if(L < arr.length && arr[L] == key) return L;
        return -1;
    }


    // 第一个>=key的:
    static int firstLargeEqual(int[] arr, int key){
        int L = 0, R = arr.length - 1;
        while(L <= R){
            int mid = L + (R - L) / 2;
            if(arr[mid] >= key)
                R = mid - 1;
            else
                L = mid + 1;
        }
        return L;
    }


    // 第一个>key的:
    static int firstLarge(int[] arr, int key){
        int L = 0, R = arr.length - 1;
        while(L <= R){
            int mid = L + (R - L) / 2;
            if(arr[mid] > key) // 因为是第一个> 的，所以>
                R = mid - 1;
            else
                L = mid + 1;
        }
        return L;
    }
    // 最后一个=key的:
    static int lastEqual(int[] arr, int key){
        int L = 0, R = arr.length - 1;
        while(L <= R){
            int mid = L + (R - L) / 2;
            if(arr[mid] <= key)
                L = mid + 1;
            else
                R = mid - 1;
        }
        if(R >= 0 && arr[R] == key)
            return R;
        return -1;
    }
    // 最后一个<=key的:
    static int lastEqualSmall(int[] arr, int key){
        int L = 0, R = arr.length - 1;
        while(L <= R){
            int mid = L + (R - L) / 2;
            if(arr[mid] <= key)
                L = mid + 1;
            else
                R = mid - 1;
        }
        return R;
    }

    // 最后一个<key的:
    static int lastSmall(int[] arr, int key){
        int L = 0, R = arr.length - 1;
        while(L <= R){
            int mid = L + (R - L) / 2;
            if(arr[mid] < key)
                L = mid + 1;
            else
                R = mid - 1;
        }
        return R;
    }

}


class BFSTemplate{
    public ArrayList<ArrayList<Integer>> levelOrder(TreeNode root){
        ArrayList result = new ArrayList();

        if(root == null){
            return result;
        }

        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.offer(root);

        while(!queue.isEmpty()){
            ArrayList<Integer> level = new ArrayList<Integer>();
            int size = queue.size();
            for(int i = 0; i < size; i++) {
                TreeNode head = queue.poll();
                level.add(head.val);
                if(head.left != null){
                    queue.offer(head.left);
                }
                if(head.right != null){
                    queue.offer(head.right);
                }
            }
            result.add(level);
        }
        return result;
    }
    class TreeNode {
        public int val;
        public TreeNode left;
        public TreeNode right;

        public TreeNode(int x) {
            val = x;
        }
    }
}


class SortTemplate{
    static void swap(int[] arr, int a, int b){
        int t = arr[a];
        arr[a] = arr[b];
        arr[b] = t;
    }
    static void bubbleSort(int[] arr){
        for(int end = arr.length - 1; end > 0; end--){
            boolean isSort = true;
            for(int i = 0; i < end; i++){
                if(arr[i] > arr[i+1]) {
                    swap(arr, i, i + 1);
                    isSort = false;
                }
            }
            if(isSort) break;
        }
    }
    static void selectSort(int[] arr){
        for(int i = 0; i < arr.length; i++){
            int minIdx = i;
            for(int j = i + 1; j < arr.length; j++) minIdx = arr[j] < arr[minIdx] ? j : minIdx;
            swap(arr, minIdx, i);
        }
    }
    // 几个边界: i=1开始(不是必须)、j >= 0, arr[j+1] = key注意一下
    static void insertSort(int[] arr) {
        for (int i = 1; i < arr.length; i++) {
            int key = arr[i], j;
            for (j = i - 1; j >= 0 && arr[j] > key; j--) arr[j + 1] = arr[j];
            arr[j + 1] = key;
        }
    }
    // 边界 j > 0
    static void insertSort2(int[] arr) {
        for (int i = 1; i < arr.length; i++) {
            for (int j = i; j > 0 && arr[j - 1] > arr[j]; j--) swap(arr, j, j - 1);
        }
    }
    // 二分插入排序,注意 R = i-1，注意找第一个>=key的，注意arr[i]先用key保存
    static void binaryInsertSort(int[] arr) {
        for (int i = 1; i < arr.length; i++) {
            int L = 0, R = i - 1;
            // 找第一个大于的 二分边界搞不清的看下面的二分链接
            int key = arr[i];
            while (L <= R) {
                int m = L + (R - L) / 2;
                if (arr[m] > arr[i]) {
                    R = m - 1;
                } else {
                    L = m + 1;
                }
            }
            for (int j = i - 1; j >= L; j--) arr[j + 1] = arr[j];
            arr[L] = key;
        }
    }
    static void shellSort(int[] arr) {
        for (int g = arr.length; g > 0; g /= 2) { // 增量序列 gap
            for (int end = g; end < arr.length; end++) { // 每一个组的结束元素, 从数组第gap个元素开始
                // 每组做插入排序
                int key = arr[end], i;
                for (i = end - g; i >= 0 && key < arr[i]; i -= g) arr[i + g] = arr[i];
                arr[i + g] = key;
            }
        }
    }

    // 给出的是三路快排
    static void quickSort(int[] arr){
        if(arr == null || arr.length == 0) return;
        quickRec(arr, 0, arr.length - 1);
    }

    static void quickRec(int[] arr, int L, int R) {
        if (L >= R) return;
        swap(arr, L, L + (int) (Math.random() * (R - L + 1)));
        int[] p = partition(arr, L, R);
        quickRec(arr, L, p[0] - 1);
        quickRec(arr, p[1] + 1, R);
    }

    // 用arr[L]作为划分点
    static int[] partition(int[] arr, int L, int R) {
        int key = arr[L];
        int less = L, more = R + 1;
        int cur = L + 1;
        while (cur < more) {
            if (arr[cur] < key) {
                swap(arr, ++less, cur++);
            } else if (arr[cur] > key) {
                swap(arr, --more, cur);
            } else {
                cur++;
            }
        }
        swap(arr, L, less);
        // 返回相等的两个下标，　less位置是我最后交换过来的划分值，more位置是>的，所以返回more-1
        return new int[]{less, more - 1};
    }


    // 归并排序
    static void mergeSort(int[] arr){
        if(arr == null || arr.length == 0) return;
        mergeRec(arr, 0, arr.length - 1);
    }

    //注意是mergeSort(arr, L, m); 不是mergeSort(arr, L, m-1)
    static void mergeRec(int[] arr, int L, int R) {
        if (L >= R) return;
        int m = L + (R - L) / 2;
        mergeRec(arr, L, m);
        mergeRec(arr, m + 1, R);
        merge(arr, L, m, R);
    }

    static void merge(int[] arr, int L, int mid, int R) {
        int[] h = new int[R - L + 1];
        int p1 = L, p2 = mid + 1;
        int k = 0;
        while (p1 <= mid && p2 <= R)
            h[k++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];  // 注意保证稳定性
        while (p1 <= mid) h[k++] = arr[p1++];
        while (p2 <= R) h[k++] = arr[p2++];
        for (int i = 0; i < k; i++) arr[L + i] = h[i];
    }

    // 非递归归并排序:
    static void mergeSortBU(int[] arr) {
        for (int sz = 1; sz <= arr.length; sz += sz) { // 区间的个数，1..2..4..8
            for (int i = 0; sz + i < arr.length; i += sz + sz) {  // 对[i...i+sz-1]和[i+sz...i+2*sz-1]内归并
                merge(arr, i, i + sz - 1, Math.min(arr.length - 1, i + 2 * sz - 1)); // min防止越界
            }
        }
    }



    // 堆排
    // if(arr == null || arr.length <= 1) return; 是必须的
    static void heapSort(int[] arr) {
        if (arr == null || arr.length <= 1) return;
        for (int i = 0; i < arr.length; i++) siftUp(arr, i);//上浮方式建堆
        int size = arr.length - 1;
        swap(arr, 0, size);
        while (size > 0) {
            siftDown(arr, 0, size);
            swap(arr, 0, --size);
        }
    }

    // 上浮
    static void siftUp(int[] arr, int i) {
        while (arr[i] > arr[(i - 1) / 2]) {
            swap(arr, i, (i - 1) / 2);
            i = (i - 1) / 2;
        }
    }

    // 下沉
    static void siftDown(int[] arr, int i, int heapSize) {
        int L = 2 * i + 1;
        while (L < heapSize) {
            int maxIndex = L + 1 < heapSize && arr[L + 1] > arr[L] ? L + 1 : L;
            maxIndex = arr[i] > arr[maxIndex] ? i : maxIndex;
            if (maxIndex == i) break;
            swap(arr, i, maxIndex);
            i = maxIndex;
            L = 2 * i + 1;
        }
    }
    // 第二种方式，使用heapfiy的优化，只需要使用siftDown过程即可。
    // 注意这里是size+1,因为这个不是交换了最后一个，所以要考虑arr[size]，下面不要考虑arr[size]
    // if (arr == null || arr.length <= 1) return; 是必须的
    static void heapSort2(int[] arr) {
        if (arr == null || arr.length <= 1) return;
        int size = arr.length - 1;
        for (int i = (size - 1) / 2; i >= 0; i--)
            siftDown(arr, i, size + 1);
        swap(arr, 0, size);
        while (size > 0) {
            siftDown(arr, 0, size);
            swap(arr, 0, --size);
        }
    }

}

class MathTemplate{
    //最大公约数
    int gcd(int p,int q){
        if(q == 0)    return p;
        return gcd(q, p % q);
    }

    //最小公倍数　
    int lcm(int p,int q){
        int pq = p * q;
        return pq / gcd(p,q);
    }
    // 求n以内的素数
    public void test3(int n){
        int num=0;
        int j;
        boolean sgin;
        for (int i = 2; i <= n; i++) {
            if(i % 2 == 0 && i != 2  )  continue; //偶数和1排除
            sgin= true;
            for (j = 2; j <= Math.sqrt(i) ; j++) {
                if (i % j == 0) {
                    sgin = false;
                    break;
                }
            }
            //打印
            if (sgin) {
                num++;
                /* System.out.println(""+i);*/
            }
        }
        System.out.println(n+"以内的素数有"+num+"个");
    }
    //利用Java判断一个数是否是素数的算法
    public static boolean f(int a) throws Exception{
        if (a < 2) {
            throw new Exception();
        }
        boolean ean = true;
        for(int i = 2 ; i <= Math.sqrt(a) ; i++){ //Math.sqrt 是调用Math类中的sqrt方法，求一个数的平方根
            if(a%i == 0){
                ean = false;
                break;
            }
        }
        return ean;
    }

    //求一个数的所有因数
    void yinshu(int n){
        System.out.print(n+"=");
        for (int i=2;i<=n;i++){
            while (n!=i){
                if(n%i==0) {
                    n = n / i;
                    System.out.print(i+"*");
                }
                else break;;
            }
        }
    }

    // 判断回文数字(判断纯数字)
    // 判断的数字是否是回文数
    public static boolean isHuiWen(int n) {
        int m = reverse(n);
        if (m == n) {
            return true;
        } else {
            return false;
        }
    }
    // 将输入的数字进行倒置，以便进行判断是否是回文数
    public static int reverse(int n) {
        int temp = 0;// 临时变量
        int j = 0;// 倒置后的数字
        temp = n;// 将输入的数字赋值给临时变量
        while (temp != 0) {
            j = j * 10 + temp % 10;
            temp /= 10;
        }
        return j;
    }


}

class StringTemplate{

    void operate(){
        String s = "helloworld";
        //int length():获取字符串的长度，其实也就是字符个数
        System.out.println(s.length());//10
        //String concat:将指定的字符串连接到该字符串的末尾
        String s2 = s.concat("**hello itheima");
        System.out.println(s2);//helloworld**hello itheima
        //char charAt：获取指定索引处的字符
        System.out.println(s.charAt(0));//h
        System.out.println(s.charAt(1));//e
        // 获取子字符串第一次出现在该字符串内的索引，没有返回-1
        System.out.println(s.indexOf("l"));//2
        System.out.println(s.indexOf("wow"));//-1
        // 从beginIndex开始截取字符串到字符串结尾
        System.out.println(s.substring(0));//helloworld
        System.out.println(s.substring(5));//world

        String str = "asdfghjkl";
        for(int i=0;i<str.length();i++){
            char ch = str.charAt(i);
        }
        char[] c=s.toCharArray();
        for(char cc:c){
            //cc直接用了
        }

        // 判断是否是回文串
        str = "abc";
        int count = 0;
        for (int i = 0; i < str.length() / 2; i++) {
            if ((str.substring(i, i + 1)).equals(str.substring(str.length() - 1- i, str.length() - i))) {
                count++;
            }
        }
        if (count == str.length() / 2) {
            System.out.println("是回文字符串");
        }else{
            System.out.println("不是回文字符串");
        }

    }

}

class BigAdd {
    //大数加法
    static String add(String str1, String str2){
        char[] s1 = str1.toCharArray();
        char[] s2 = str2.toCharArray();
        int n1 = s1.length, n2 = s2.length;
        int maxL = Math.max(n1, n2);
        int[] a = new int[maxL + 1];//注意a,b的数组大小都必须是maxL+1
        int[] b = new int[maxL + 1];
        for(int i = 0; i < n1; i++) a[i] = s1[n1 - i - 1] - '0';
        for(int i = 0; i < n2; i++) b[i] = s2[n2 - i - 1] - '0';
        for(int i = 0; i < maxL; i++){
            if(a[i] + b[i] >= 10){
                int tmp = a[i] + b[i];//注意一定要先抽取出来
                a[i] = tmp%10;
                a[i+1] += tmp/10;
            }else
                a[i] += b[i];
        }
        StringBuilder sb = new StringBuilder();
        if(a[maxL] != 0) sb.append((char)(a[maxL] + '0'));
        for(int i = maxL-1; i >= 0; i--) sb.append((char)(a[i] + '0'));
        return sb.toString();
    }
}

class BigMul {

    // 大数乘法
    static String mul(String str1, String str2){
        char[] s1 = str1.toCharArray();
        char[] s2 = str2.toCharArray();
        int n1 = s1.length, n2 = s2.length;
        int[] a = new int[n1];
        int[] b = new int[n2];
        int[] c = new int[n1 + n2];
        for(int i = 0; i < n1; i++) a[i] = s1[n1 - i - 1] - '0';
        for(int i = 0; i < n2; i++) b[i] = s2[n2 - i - 1] - '0';
        for(int i = 0; i < n1; i++){
            for(int j = 0; j < n2; j++){
                c[i+j] += a[i] * b[j];
            }
        }
        for(int i = 0; i < n1 + n2 - 1; i++){
            if(c[i] >= 10){
                c[i+1] += c[i]/10;
                c[i] %= 10;
            }
        }
        int i;
        for(i = n1 + n2 - 1; i >= 0; i--) if(c[i] != 0) break;
        StringBuilder sb = new StringBuilder();
        for(; i >= 0; i--) sb.append( (char)(c[i] + '0'));
        return sb.toString();
    }
}

class Permutation {

    static PrintStream out = System.out;

    // 1 ~ n 的排列
    static void permutation(int[] tmp, int cur, int n) {
        if (cur == n) {  // 边界
            for (int i = 0; i < n; i++)
                out.print(tmp[i] + " ");
            out.println();
        } else for (int i = 1; i <= n; i++) {  //尝试在arr[cur]中填充各种整数 (1~n)
            boolean flag = true;
            for (int j = 0; j < cur; j++)
                if (i == tmp[j]) {  // 如果i已经在arr[0]~arr[cur-1]中出现过，则不能选
                    flag = false;
                    break;
                }
            if (flag) {
                tmp[cur] = i;  //把i填充到当前位置
                permutation(tmp, cur + 1, n);
            }
        }
    }

    // 数组的去重全排列
    // tmp存放排列，arr是原数组
    static void permutation(int[] tmp, int[] arr, int cur, int n) {
        if (cur == n) {
            for (int i = 0; i < n; i++)
                out.print(tmp[i] + " ");
            out.println();
        } else for (int i = 0; i < n; i++) if (i == 0 || arr[i] != arr[i - 1]) {
            int c1 = 0, c2 = 0;
            for (int j = 0; j < n; j++)
                if (arr[j] == arr[i]) // 重复元素的个数
                    c1++;
            for (int j = 0; j < cur; j++)
                if (tmp[j] == arr[i]) // 前面已经排列的重复元素的个数
                    c2++;
            if (c2 < c1) {
                tmp[cur] = arr[i];
                permutation(tmp, arr, cur + 1, n);
            }
        }
    }

    //非去重　经典全排列
    static void permutation_2(int[] arr, int cur, int n){
        if(cur == n){
            for(int i = 0; i < n; i++) out.print(arr[i] + " ");
            out.println();
            return;
        }
        for(int i = cur; i < n; i++){
            swap(arr, i, cur);
            permutation_2(arr, cur + 1, n);
            swap(arr, i, cur);
        }
    }

    static void swap(int[] arr, int a, int b){
        int t = arr[a];
        arr[a] = arr[b];
        arr[b] = t;
    }

    // 用一个used数组来求得全排列
    static void dfs(int[] arr, ArrayList<Integer> list, boolean[] used){
        if(list.size() == arr.length){
            for(int num :  list) out.print(num + " ");
            out.println();
            return;
        }
        for(int i = 0; i < arr.length; i++){
            //  if (used[i] || (i > 0 && !used[i - 1] && arr[i] == arr[i - 1])) continue; // 去重的写法，去重要先排序 Arrays.sort(arr);
            if(used[i]) continue;
            used[i] = true;
            list.add(arr[i]);

            dfs(arr, list, used);

            list.remove(list.size() - 1);
            used[i] = false;
        }
    }

    public static void main(String[] args) {
        int n = 5;
        permutation(new int[n], 0, n);

        out.println("--------------");

        int[] arr = {1, 1, 1};
        // 需要先排序 , 上面的排列只会输出 1,1,1因为我们去重了
        Arrays.sort(arr);
        permutation(new int[arr.length], arr, 0, arr.length);

        out.println("--------------");
        permutation_2(new int[]{1, 1}, 0, 2); // 输出两个{1, 1}

        out.println("---------------");

        dfs(new int[]{1, 3, 2}, new ArrayList<>(), new boolean[3]);
    }
}
class Subset {

    static PrintStream out = System.out;

    //打印0~n-1的所有子集
    //按照递增顺序就行构造子集 防止子集的重复
    static void print_subset(int[] arr, int cur, int n){
        for(int i = 0; i < cur; i++)
            out.print(arr[i] + " ");
        out.println();
        int s = cur != 0 ? arr[cur-1] + 1 : 0;  //确定当前元素的最小可能值
        for(int i = s; i < n; i++){
            arr[cur] = i;
            print_subset(arr, cur+1, n);
        }
    }

    // 1~n 的所有子集：位向量法
    static void print_subset(int cur, boolean[] bits, int n) {
        if (cur == n+1) {
            for (int i = 1; i < cur; i++)
                if (bits[i])
                    out.print(i + " ");
            out.println();
            return;
        }
        bits[cur] = true;
        print_subset(cur + 1, bits, n);
        bits[cur] = false;
        print_subset(cur + 1, bits, n);
    }

    // 0 ~ n-1的所有子集：二进制法枚举0 ~ n-1的所有子集
    static void print_subset(int n){
        for(int mask = 0; mask < (1 << n); mask++){
            for(int i = 0; i < n; i++)
                if( ((mask >> i) & 1) == 1)  //和下面一样
//                if( ((1 << i) & mask) != 0)
                    out.print(i + " ");
            out.println();
        }
    }

    public static void main(String[] args){
        int n = 3;
        // 0~n-1的子集
        print_subset(new int[n], 0, n);
        out.println("---------------");

        // 1 ~ n 的子集
        print_subset(1, new boolean[n+1], n);
        out.println("---------------");

        // 1~n的子集
        print_subset(n);
    }
}

/**
 * 基于rank的并查集
 * 题目链接：http://poj.org/problem?id=1611
 * 题目大意 : 病毒传染，可以通过一些社团接触给出一些社团(0号人物是被感染的)问有多少人(0~n-1个人)被感染
 *
 *
 * 描述
 *
 * 严重急性呼吸道综合症（SARS）是一种病因不明的非典型肺炎，在2003年3月中旬被认为是全球性威胁。为了最大程度地减少向他人的传播，
 * 最好的策略是将嫌疑犯与其他人分开。 在不蔓延疾病大学（NSYSU）中，有很多学生团体。同一组中的学生经常互相交流，一个学生可以加
 * 入多个组。为了防止可能的SARS传播，NSYSU收集所有学生团体的成员列表，并在其标准操作程序（SOP）中制定以下规则。 一旦组中的某
 * 个成员成为可疑对象，该组中的所有成员都是可疑对象。 但是，他们发现，当一个学生被确认为犯罪嫌疑人时，要识别所有犯罪嫌疑人并不
 * 容易。您的工作是编写一个找到所有嫌疑犯的程序。
 *
 * 输入值：
 * 输入文件包含几种情况。每个测试用例均以一行中的两个整数n和m开头，其中n是学生数，m是组数。您可以假设0 <n <= 30000并且0 <= m <=500。
 * 每个学生都用0到n-1之间的唯一整数编号，并且最初在所有情况下，学生0都被认为是可疑者。该行之后是组的m个成员列表，每组一行。每行以一个整
 * 数k开头，它本身代表组中的成员数。在成员数之后，有k个整数表示该组中的学生。一行中的所有整数至少间隔一个空格。
 * n = 0和m = 0的情况表示输入的结束，无需处理。
 *
 * 输出量：
 * 对于每种情况，在一行中输出可疑对象的数量。
 *
 * 样本输入：
 * 100 4
 * 2 1 2
 * 5 10 13 11 12 14
 * 2 0 1
 * 2 99 2
 *
 * 200 2
 * 1 5
 * 5 1 2 3 4 5
 *
 * 1 0
 * 0 0
 *
 * 样本输出：（有三组样本，所以输出3个结果）
 * 4
 * 1个
 * 1个
 */

class UnionFind_1 {

    static int[] f;
    static int[] rank;

    static int findRoot(int p) {
        while (p != f[p]) {
            f[p] = f[f[p]];
            p = f[p];
        }
        return p;
    }

    static void union(int a, int b) {
        int aR = findRoot(a);
        int bR = findRoot(b);
        if (aR == bR) return;
        if (rank[aR] < rank[bR]) {
            f[aR] = f[bR];
        } else if (rank[aR] > rank[bR]) {
            f[bR] = f[aR];
        } else {
            f[aR] = f[bR];
            rank[bR]++;
        }
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedInputStream(System.in));
        PrintStream out = System.out;
        while (in.hasNext()) {
            int n = in.nextInt();
            int m = in.nextInt();
            if(n == 0 && m == 0) break;
            f = new int[n];
            rank = new int[n];
            for(int i = 0; i < n; i++) {
                f[i] = i;
                rank[i] = 1;
            }
            for(int i = 0; i < m; i++){
                int c = in.nextInt();
                int root = in.nextInt();
                for(int j = 0; j < c - 1; j++) {
                    int num = in.nextInt();
                    union(root, num);
                }
            }
            int res = 1; // 0已经感染
            for(int i = 1; i < n; i++)
                if(findRoot(0) == findRoot(i)) res++;
            out.println(res);
        }
    }
}

/**
 * 基于size的并查集
 * 题目链接：http://poj.org/problem?id=1611
 * 题目大意 : 病毒传染，可以通过一些社团接触给出一些社团(0号人物是被感染的)问有多少人(0~n-1个人)被感染
 */
class UnionFind_2 {

    static int[] f;
    static int[] sz; // size

    static int findRoot(int p) {
        while (p != f[p]) {
            f[p] = f[f[p]];
            p = f[p];
        }
        return p;
    }

    // 将元素个数少的集合合并到元素个数多的集合上
    static void union(int a, int b) {
        int aR = findRoot(a);
        int bR = findRoot(b);
        if (aR == bR) return;
        if (sz[aR] < sz[bR]) {
            f[aR] = f[bR];
            sz[bR] += sz[aR]; // 更新集合元素个数
        }else{
            f[bR] = f[aR];
            sz[aR] += sz[bR];
        }
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedInputStream(System.in));
        PrintStream out = System.out;
        while (in.hasNext()) {
            int n = in.nextInt();
            int m = in.nextInt();
            if(n == 0 && m == 0) break;
            f = new int[n];
            sz = new int[n];
            for(int i = 0; i < n; i++) {
                f[i] = i;
                sz[i] = 1;
            }
            for(int i = 0; i < m; i++){
                int c = in.nextInt();
                int root = in.nextInt();
                for(int j = 0; j < c - 1; j++) {
                    int num = in.nextInt();
                    union(root, num);
                }
            }
            int res = 1; // 0已经感染
            for(int i = 1; i < n; i++) if(findRoot(0) == findRoot(i)) res++;
            out.println(res);
        }
    }
}

/**
 * KMP: 模式串匹配问题
 * 题目: http://acm.hdu.edu.cn/showproblem.php?pid=1711
 *
 * 问题描述
 * 给定两个数字序列：a [1]，a [2]，......，a [N]和b [1]，b [2]，......，b [M] （1 <= M <= 10000，1 <= N <= 1000000）。
 * 您的任务是找到一个使a [K] = b [1]，a [K + 1] = b [2]，......，a [K + M-1] = b [ M]。如果存在一个以上的K，则输出最小的K。
 *
 * 输入值
 * 输入的第一行是数字T，表示案件数。每个案例包含三行。第一行是两个数字N和M（1 <= M <= 10000，1 <= N <= 1000000）。
 * 第二行包含N个整数，分别表示a [1]，a [2]，......，a [N]。第三行包含M个整数，分别表示b [1]，b [2]，......，b [M]。
 * 所有整数都在[-1000000，1000000]范围内。
 *
 * 输出量
 * 对于每个测试用例，您应该输出仅包含上述K的一行。如果不存在这样的K，则输出-1。
 *
 * 样本输入
 * 2
 * 13 5
 * 1 2 1 2 3 1 2 3 1 3 2 1 2
 * 1 2 3 1 3
 * 13 5
 * 1 2 1 2 3 1 2 3 1 3 2 1 2
 * 1 2 3 2 1
 *
 * 样本输出
 * 6
 * -1
 */
class KMP {

    static int kmp(int[] s, int[] p) {
        if (s == null || p == null || s.length < p.length || p.length == 0)
            return -1;
        int[] next = getNext(p);
        int i1 = 0, i2 = 0;
        while (i1 < s.length && i2 < p.length) {
            if (s[i1] == p[i2]) {
                i1++;
                i2++;
            } else {
                if (next[i2] == -1) {
                    i1++;
                } else {
                    i2 = next[i2];
                }
            }
        }
        return i2 == p.length ? i1 - i2 : -1; // 返回i2在i1匹配到的第一个位置
    }

    /**
     * next数组含义:
     * next[i]的含义是在str[i]之前的字符串也就是: str[0...i)中，
     * 必须以str[i-1]结尾的后缀子串(不能包含str[0]) 和
     * 必须以str[0]开头的前缀子串(不能包含str[i-1])的最大匹配长度
     */
    static int[] getNext(int[] arr) {
        if (arr.length == 1) return new int[]{-1};
        int[] next = new int[arr.length + 1];
        next[0] = -1;
        next[1] = 0;
        int cn = 0;
        for (int i = 2; i <= arr.length; ) {
            if (arr[i - 1] == arr[cn]) {
                next[i++] = ++cn;
            } else {
                if (cn > 0) {
                    cn = next[cn];
                } else {
                    next[i++] = 0;
                }
            }
        }
        return next;
    }

    public static void main(String[] args) {
//        System.out.println(Arrays.toString(getNext(new int[]{1, 2, 3, 1, 2})));
        Scanner cin = new Scanner(new BufferedInputStream(System.in));
        int k = cin.nextInt();
        while (k-- > 0) {
            int n = cin.nextInt();
            int m = cin.nextInt();
            int[] s = new int[n];
            int[] p = new int[m]; //切记不能随便new int[n+1]因为后面用length代替了n
            for (int i = 0; i < n; i++) s[i] = cin.nextInt();
            for (int i = 0; i < m; i++) p[i] = cin.nextInt();
            int res = kmp(s, p);
            System.out.println(res == -1 ? -1 : res + 1);
        }
    }
}

/**
 * 马拉车算法: 解决O(N)求最长回文串问题
 * 题目：http://acm.hdu.edu.cn/showproblem.php?pid=3068
 *
 * 备注: 如果要求出最长回文，就记录一下取得最长回文的时候最长半径的位置即可
 *
 * 给出一个只由小写英文字符a,b,c...y,z组成的字符串S,求S中最长回文串的长度.
 * 回文就是正反读都是一样的字符串,如aba, abba等
 *
 * Input
 * 输入有多组case,不超过120组,每组输入为一行小写英文字符a,b,c...y,z组成的字符串S
 * 两组case之间由空行隔开(该空行不用处理)
 * 字符串长度len <= 110000
 *
 * Output
 * 每一行一个整数x,对应一组case,表示该组case的字符串中所包含的最长回文长度.
 *
 * Sample Input
 * aaaa
 * abab
 *
 * Sample Output
 * 4
 * 3
 */
class Manacher {

    /**
     * 获取指定格式的字符串(中间和两边都带有#) 这样可以处理偶回文
     * 例如 : 如果是abc -->#a#b#c#
     * 如果是abcd -->#a#b#c#d#
     */
    static char[] manacherString(String str) {
        char[] res = new char[str.length() * 2 + 1];
        int index = 0;
        for (int i = 0; i < res.length; i++)
            res[i] = ((i & 1) == 0) ? '#' : str.charAt(index++);
        return res;
    }

    static int manacher(String s) {
        if (s == null || s.length() == 0) return 0;
        char[] chs = manacherString(s);
        int[] r = new int[chs.length]; //记录每个位置的最长回文半径,注意是chs的长度
        int R = -1, C = -1;  //分别代表目前的最长回文右边界，和它的中心
        int max = Integer.MIN_VALUE;   //记录结果
        for (int i = 0; i < chs.length; i++) {
            r[i] = R > i ? Math.min(r[2 * C - i], R - i) : 1; //这句代码包含三种情况 第一种大情况,和二种中的(1)(2)情况
            while (i + r[i] < chs.length && i - r[i] >= 0) { //不越界 //注意这包括了四种情况，都要扩一下，为了节省代码
                if (chs[i + r[i]] == chs[i - r[i]]) { // 往前面扩一下
                    r[i]++;
                } else { //扩不动了
                    break;
                }
            }
            if (i + r[i] > R) { //更新最右边界和它的中心
                R = i + r[i];
                C = i;
            }
            max = Math.max(max, r[i]); //取最大的r[i] (r[i]记录的是每个位置的最长回文半径)
        }
        return max - 1; //求出来的是加了'#'的
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedInputStream(System.in));
        while (in.hasNext()) {
            String s = in.next();
            System.out.println(manacher(s));
        }
    }
}

/**
 * BFS拓扑排序，拓扑排序是AOV网
 * 题目: https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1246
 *
 * 约翰有n件事要做。不幸的是，这些任务不是独立的，只有在其他任务已经执行的情况下才能执行一个任务。
 *
 * input：
 * 输入将包含问题的多个实例。每个实例以包含两个整数，1≤n≤100，m.n是任务数（从1到n编号），m是
 * 任务之间的直接优先关系数。在此之后，将有两个整数的m行i和j，表示任务i必须在任务j之前执行。
 * n=m=0的实例将完成输入。
 *
 * output：
 * 对于每个实例，打印一行包含n个整数的行，这些整数表示按可能的执行顺序执行的任务。
 *
 * Sample Input
 * 5 4
 * 1 2
 * 2 3
 * 1 3
 * 1 5
 * 0 0
 * Sample Output
 * 1 4 2 5 3
 *
 */
class TopologySort_1 {

    static ArrayList<Integer> G[];
    static int[] in;
    static int n, m;
    static PrintStream out;

    static void topologySort() {
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 1; i <= n; i++) if (in[i] == 0) queue.add(i);
        boolean flag = true; // for output
        while (!queue.isEmpty()) {
            int cur = queue.poll();
            if (flag) {
                out.print(cur);
                flag = false;
            } else
                out.print(" " + cur);
            for (int i = 0; i < G[cur].size(); i++) {
                int to = G[cur].get(i);
                if (--in[to] == 0)
                    queue.add(to);
            }
        }
        out.println();
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(new BufferedInputStream(System.in));
        out = System.out;
        while (sc.hasNext()) {
            n = sc.nextInt();
            m = sc.nextInt();
            if (n == 0 && m == 0)
                break;
            in = new int[n + 1];
            G = new ArrayList[n + 1];
            for (int i = 0; i <= n; i++)
                G[i] = new ArrayList<>();
            for (int i = 0; i < m; i++) {
                int from = sc.nextInt();
                int to = sc.nextInt();
                G[from].add(to);
                in[to]++;
            }
            topologySort();
        }
    }
}
/**
 * 第二种利用dfs记录三个状态:
 * DFS拓扑排序
 * 题目: https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1246
 */
class TopologySort_2 {

    static ArrayList<Integer> G[];
    static int[] vis;
    static int n, m;
    static int[] res;
    static int p;

    static boolean dfs(int cur) {
        vis[cur] = 2; // now is visiting
        for (int to : G[cur]) {
            if (vis[to] == 2 || (vis[to] == 0 && !dfs(to))) // exist directed cycle
                return false;
        }
        vis[cur] = 1; // now is visited
        res[p--] = cur;
        return true;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(new BufferedInputStream(System.in));
        PrintWriter out = new PrintWriter(System.out);
        while (sc.hasNext()) {
            n = sc.nextInt();
            m = sc.nextInt();
            if (n == 0 && m == 0)
                break;
            G = new ArrayList[n + 1];
            vis = new int[n + 1];
            for (int i = 0; i <= n; i++)
                G[i] = new ArrayList<>();
            for (int i = 0; i < m; i++) {
                int from = sc.nextInt();
                int to = sc.nextInt();
                G[from].add(to);
            }
            p = n - 1;  // back to front
            res = new int[n + 1];
            boolean ok = true;
            for (int i = 1; i <= n; i++) {
                if (vis[i] == 0)
                    dfs(i);
            }
            for (int i = 0; i < n - 1; i++)
                out.print(res[i] + " ");
            out.println(res[n - 1]);
            out.flush();
        }
        out.close();
    }
}

/**
 * 最小生成树 Kruskal
 * 题目: http://acm.hdu.edu.cn/showproblem.php?pid=1863
 *
 * 省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可）。
 * 经过调查评估，得到的统计表中列出了有可能建设公路的若干条道路的成本。现请你编写程序，计算出全省畅通需要的最低成本。
 *
 *
 * Input
 * 测试输入包含若干测试用例。每个测试用例的第1行给出评估的道路条数 N、村庄数目M ( < 100 )；随后的 N
 * 行对应村庄间道路的成本，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间道路的成本（也是正整数）。
 * 为简单起见，村庄从1到M编号。当N为0时，全部输入结束，相应的结果不要输出。
 *
 *
 * Output
 * 对每个测试用例，在1行里输出全省畅通需要的最低成本。若统计数据不足以保证畅通，则输出“?”。
 *
 *
 * Sample Input
 * 3 3
 * 1 2 1
 * 1 3 2
 * 2 3 4
 * 1 3
 * 2 3 2
 * 0 100
 *
 *
 * Sample Output
 * 3
 * ?
 *
 */
 class MST_Kruskal {

    static int n;
    static int m;
    static ArrayList<Edge> edges;

    static class Edge implements Comparable<Edge> {
        public int from;
        public int to;
        public int w;

        public Edge(int from, int to, int w) {
            this.from = from;
            this.to = to;
            this.w = w;
        }

        @Override
        public int compareTo(Edge o) {
            return w - o.w;
        }
    }

    static class UF {

        int[] parent;
        int[] rank;

        public UF(int n) {
            parent = new int[n + 1];
            rank = new int[n + 1];
            for (int i = 0; i <= n; i++) {
                parent[i] = i;
                rank[i] = 0;
            }
        }

        public boolean isSameSet(int x, int y) {
            return find(x) == find(y);
        }

        public int find(int v) {
            while (parent[v] != v) {
                parent[v] = parent[parent[v]];  // 路径压缩优化
                v = parent[v];
            }
            return v;
        }

        public void union(int a, int b) {
            int aR = find(a);
            int bR = find(b);
            if (aR == bR)
                return;
            if (rank[aR] < rank[bR]) { // a更矮,所以挂到b更好
                parent[aR] = bR;
            } else if (rank[aR] > rank[bR]) {
                parent[bR] = aR;
            } else {
                parent[aR] = bR;
                rank[bR]++;
            }
        }
    }

    static int kruskal() {
        Collections.sort(edges);  // 对边集排序
        UF uf = new UF(n);
        int res = 0;
        int count = 0;
        for (int i = 0; i < edges.size(); i++) {
            int from = edges.get(i).from;
            int to = edges.get(i).to;
            int w = edges.get(i).w;
            if (!uf.isSameSet(from, to)) { //两个顶点不属于同一个集合
                res += w;
                count++;
                if (count == n - 1)
                    break;
                uf.union(from, to);
            }

        }
        return count == n - 1 ? res : -1;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedInputStream(System.in));
        while (in.hasNext()) {
            m = in.nextInt(); // 先输入道路条数
            n = in.nextInt();
            if (m == 0)
                break;
            edges = new ArrayList<>();
            for (int i = 0; i < m; i++) {
                int from = in.nextInt();
                int to = in.nextInt();
                int w = in.nextInt();
                edges.add(new Edge(from, to, w));
                edges.add(new Edge(to, from, w));
            }
            int res = kruskal();
            System.out.println(res == -1 ? "?" : res);
        }
    }
}

/**
 * 最小生成树 Prim
 * 题目：http://acm.hdu.edu.cn/showproblem.php?pid=1863
 */
class MST_Prim {

    static int n, m;
    static boolean[] vis;
    static ArrayList<Edge>[] G;

    static class Edge implements Comparable<Edge> {
        public int to;
        public int w;

        public Edge(int to, int w) {
            this.to = to;
            this.w = w;
        }

        @Override
        public int compareTo(Edge o) {
            return w - o.w;
        }
    }

    private static int prim(int start) {
        PriorityQueue<Edge> pq = new PriorityQueue<>();
        for (int i = 0; i < G[start].size(); i++)
            pq.add(G[start].get(i));
        int count = 0;
        int res = 0;
        vis[start] = true; // 起始节点已经在集合中
        while (!pq.isEmpty()) {
            Edge curEdge = pq.poll();
            int to = curEdge.to;
            if (!vis[to]) {
                vis[to] = true;
                count++;
                res += curEdge.w;
                if (count == n - 1)
                    break;
                for (int i = 0; i < G[to].size(); i++) {
                    int nxtNode = G[to].get(i).to;
                    if (!vis[nxtNode]) // to -> nxtNode 没有加入过
                        pq.add(G[to].get(i)); // 将to-> nxtNode的边加入优先队列
                }
            }
        }
        if (count != n - 1)
            return -1;
        return res;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedInputStream(System.in));
        while (in.hasNext()) {
            m = in.nextInt(); // 先输入道路条数
            n = in.nextInt();
            if (m == 0)
                break;
            G = new ArrayList[n + 1];  // 1~n
            vis = new boolean[n + 1];
            for (int i = 0; i <= n; i++)
                G[i] = new ArrayList<>();
            for (int i = 0; i < m; i++) {
                int from = in.nextInt();
                int to = in.nextInt();
                int w = in.nextInt();
                G[from].add(new Edge(to, w));
                G[to].add(new Edge(from, w));
            }
            int res = prim(1);
            System.out.println(res == -1 ? "?" : res);
        }
    }
}

/**
 * 最短路径，迪杰斯特拉可求一个顶点到其他任意一个顶点的距离
 * 例题: http://acm.hdu.edu.cn/showproblem.php?pid=1874
 *
 * 每组数据第一行包含两个正整数N和M(0<N<200,0<M<1000)，分别代表现有城镇的数目和已修建的道路的数目。城镇分别以0～N-1编号。
 * 接下来是M行道路信息。每一行有三个整数A,B,X(0<=A,B<N,A!=B,0<X<10000),表示城镇A和城镇B之间有一条长度为X的双向道路。
 * 再接下一行有两个整数S,T(0<=S,T<N)，分别代表起点和终点。
 *
 * Sample Input:
 * 3 3
 * 0 1 1
 * 0 2 3
 * 1 2 1
 * 0 2
 */
class Dijkstra {

    static int n;
    static int m;
    static boolean[] vis;
    static ArrayList<Edge> G[];

    static class Edge implements Comparable<Edge> {
        public int to;
        public int w;

        public Edge(int to, int w) {
            this.to = to;
            this.w = w;
        }

        @Override
        public int compareTo(Edge o) {
            return w - o.w;
        }
    }

    static int[] dijkstra(int start) {
        PriorityQueue<Edge> pq = new PriorityQueue<>();
        int[] dis = new int[n];
        for (int i = 0; i < n; i++) dis[i] = Integer.MAX_VALUE; //初始标记（不是-1(因为是求最小的)）
        dis[start] = 0;
//        G.vis[start] = true;  //第一个访问 start, 不能将start标记为true
        pq.add(new Edge(start, 0)); //将第一条边加入 pq, 自环边
        while (!pq.isEmpty()) {
            Edge curEdge = pq.poll();
            int to = curEdge.to;
            if (vis[to])
                continue;
            vis[to] = true;
            for (int i = 0; i < G[to].size(); i++) { //更新相邻的边
                int nxtNode = G[to].get(i).to;
                int nxtW = G[to].get(i).w;
                if (!vis[nxtNode] && dis[nxtNode] > dis[to] + nxtW) {
                    dis[nxtNode] = dis[to] + nxtW;
                    pq.add(new Edge(nxtNode, dis[nxtNode])); //将这个新的dis[nxtNode]加入优先队列，没准它是下一个(很小)
                }
            }
        }
        return dis;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedInputStream(System.in));
        while (in.hasNext()) {
            n = in.nextInt();
            m = in.nextInt();
            G = new ArrayList[n]; // 0~n-1
            vis = new boolean[n];
            for (int i = 0; i < n; i++) {
                G[i] = new ArrayList<>();
                vis[i] = false;
            }
            for (int i = 0; i < m; i++) {
                int from = in.nextInt();
                int to = in.nextInt();
                int w = in.nextInt();
                G[from].add(new Edge(to, w));
                G[to].add(new Edge(from, w));
            }
            int s = in.nextInt();
            int e = in.nextInt();
            int[] dis = dijkstra(s);
            System.out.println(dis[e] == Integer.MAX_VALUE ? -1 : dis[e]);
        }
    }
}

/**
 * 欧拉回路和路径 (1) 用dfs判连通
 * 题目链接: http://acm.hdu.edu.cn/showproblem.php?pid=1878
 *
 * 欧拉回路是指不令笔离开纸面，可画过图中每条边仅一次，且可以回到起点的一条回路。现给定一个图，问是否存在欧拉回路？
 *
 * 测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是节点数N ( 1 < N < 1000 )和边数M；
 * 随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个节点的编号（节点从1到N编号）。当N为0时输入结束。
 *
 * 每个测试用例的输出占一行，若欧拉回路存在则输出1，否则输出0。
 * Sample Input
 * 3 3
 * 1 2
 * 1 3
 * 2 3
 * 3 2
 * 1 2
 * 2 3
 * 0
 *
 *
 * Sample Output
 * 1
 * 0
 */
class EulerCircuit_1 {

    static ArrayList<Integer> G[];
    static int n, m;
    static boolean[] vis;

    static void dfs(int cur){
        if(vis[cur]) return;
        vis[cur] = true;
        for(int to : G[cur]){
            if(!vis[to])
                dfs(to);
        }
    }

    public static void main(String[] args){
        Scanner sc = new Scanner(new BufferedInputStream(System.in));
        PrintWriter out = new PrintWriter(System.out);
        while(sc.hasNext()){
            n = sc.nextInt();
            if(n == 0) break;
            m = sc.nextInt();
            int[] in = new int[n+1];
            vis = new boolean[n+1];
            G = new ArrayList[n+1];
            for(int i = 0; i <= n; i++) G[i] = new ArrayList<>();
            for(int i = 0; i < m; i++){
                int from = sc.nextInt();
                int to = sc.nextInt();
                G[from].add(to);
                G[to].add(from);
                in[from]++;
                in[to]++;
            }
            dfs(1);
            boolean ok = true;
            for(int i = 1; i <= n; i++) if(in[i] % 2 != 0 || !vis[i]){
                ok = false;
                break;
            }
            out.println(ok ? "1" : "0");
            out.flush();
        }
        out.close();
    }
}

// 使用并查集判断连通
class EulerCircuit_2 {

    static int n, m;
    static int[] parent, rank;

    static int findRoot(int p){
        while(p != parent[p]){
            parent[p] = parent[parent[p]];
            p = parent[p];
        }
        return p;
    }

    static void union(int a, int b){
        int aR = findRoot(a);
        int bR = findRoot(b);
        if(aR == bR) return;
        if(rank[aR] < rank[bR]){
            parent[aR] = bR;
        }else if(rank[aR] > rank[bR]){
            parent[bR] = aR;
        }else {
            parent[aR] = bR;
            rank[bR]++;
        }
    }

    public static void main(String[] args){
        Scanner sc = new Scanner(new BufferedInputStream(System.in));
        PrintWriter out = new PrintWriter(System.out);
        while(sc.hasNext()){
            n = sc.nextInt();
            if(n == 0) break;
            m = sc.nextInt();
            int[] in = new int[n+1];
            parent = new int[n+1];
            rank = new int[n+1];
            for(int i = 0; i <= n; i++) {
                parent[i] = i;
                rank[i] = 1;
            }
            for(int i = 0; i < m; i++){
                int from = sc.nextInt();
                int to = sc.nextInt();
                union(from, to);
                in[from]++;
                in[to]++;
            }
            int oneRoot = findRoot(1);
            boolean ok = in[1] % 2 == 0;
            for(int i = 2; i <= n; i++) if(in[i] % 2 != 0 || findRoot(i) != oneRoot){
                ok = false;
                break;
            }
            out.println(ok ? "1" : "0");
            out.flush();
        }
        out.close();
    }
}
/**
 * 最大公约数和最小公倍数问题
 * 题目链接:  http://acm.hdu.edu.cn/showproblem.php?pid=1019
 */
class GCD_LCM {

    // 非递归gcd
    static int gcdIter(int a, int b){
        int r;
        while(b != 0){
            r = a % b;
            a = b;
            b = r;
        }
        return a;
    }

    static int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }

    static int lcm(int a, int b) {
        return a / gcd(a, b) * b;
    }

    static int ngcd(int arr[], int n) {
        if (n == 1) return arr[0];
        return gcd(arr[n - 1], ngcd(arr, n - 1));
    }

    static int nlcm(int arr[], int n) {
        if (n == 1) return arr[0];
        return lcm(arr[n - 1], nlcm(arr, n - 1));
    }

    public static void main(String[] args){

        Scanner in = new Scanner(new BufferedInputStream(System.in));
        int T = in.nextInt();
        for(int t = 0; t < T; t++){
            int n = in.nextInt();
            int[] a = new int[n];
            for(int i = 0; i < n; i++) a[i] = in.nextInt();
            System.out.println(nlcm(a, n));
        }
    }
}

/**
 * 素数筛法,主要是埃式筛法
 */
class PrimeSieve {

    // 经典筛法，超时
    static ArrayList<Integer> primary(boolean[] is_prime, int MAX) {
        ArrayList<Integer> prime = new ArrayList<>();
        is_prime[0] = is_prime[1] = false; // 01 不是素数
        boolean flag;
        for (int i = 2; i <= MAX; i++) { //范围是1000 我筛选 0~2000内的素数
            flag = true;
            for (int j = 2; j * j <= i; j++) {// 根号i的时间复杂度
                if (i % j == 0) {
                    is_prime[i] = false;
                    flag = false;
                    break;
                }
            }
            if (flag) {
                prime.add(i);
                is_prime[i] = true;
            }
        }
        return prime;
    }


    //经典的埃式筛法
    static ArrayList<Integer> sieve(boolean[] is_prime, int MAX) {

        ArrayList<Integer> prime = new ArrayList<>();
        Arrays.fill(is_prime, true);

        is_prime[0] = is_prime[0] = false;

        for (int i = 2; i <= MAX; i++) {
            if (is_prime[i]) {
                prime.add(i);
                for (int j = 2 * i; j <= MAX; j += i)
                    is_prime[j] = false;
            }
        }

        return prime;
    }

    //优化筛法
    static ArrayList<Integer> sieve2(boolean[] is_prime, int MAX) {
        ArrayList<Integer> prime = new ArrayList<>();
        Arrays.fill(is_prime, true);
        is_prime[0] = is_prime[0] = false;
        for (int i = 2; i <= MAX; i++) {
            if (is_prime[i])
                prime.add(i);
            for (int j = 0; j < prime.size() && prime.get(j) <= MAX / i; j++) {
                is_prime[prime.get(j) * i] = false; //筛掉  (小于等于i的素数 * i)  构成的合数
                if (i % prime.get(j) == 0) //如果 i是 < i的素数的倍数 就不用筛了
                    break;
            }
        }

        return prime;
    }


    static boolean isPalindrome(int num) {
        int oldNum = num;
        int newNum = 0;
        //反过来计算
        while (num > 0) {
            newNum = newNum * 10 + num % 10;
            num /= 10;
        }
        return newNum == oldNum;
    }

    static final int maxn = 9989899; //题目中最大的回文素数

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedInputStream(System.in));
        boolean[] is_prime = new boolean[maxn + 1];

        // 三种筛法对比
//        primary(is_prime,maxn); //超时
//        sieve(is_prime,maxn); // ok
        sieve2(is_prime, maxn); // ok  fast

        ArrayList<Integer> res = new ArrayList<>();
        for (int i = 0; i <= maxn; i++) {
            if (is_prime[i] && isPalindrome(i))
                res.add(i);
        }
        while (in.hasNext()) {
            int a = in.nextInt();
            int b = in.nextInt();
            int num = 0;
            for (int i = 0; i < res.size(); i++) {
                num = res.get(i);
                if(num >= a && num <= b) System.out.println(num);
            }
            System.out.println();
        }
    }
}

// 字典树,树中有"abc","ab","ab","abd","bc","bd","cd","cde","ce"总共9个字符串。结构:
class TrieDemo {

    // Trie
    static class Trie {

        private class Node {
            int path;
            int end;
            Node[] next;//使用整数表示字符　c - 'a'

            public Node() {
                path = 0;
                end = 0;
                next = new Node[26];
            }
        }

        private Node root;

        public Trie() {
            root = new Node();
        }

        //插入一个字符串
        public void insert(String word) {
            if (word == null)
                return;
            Node cur = root;
            int index = 0;
            for (int i = 0; i < word.length(); i++) {
                index = word.charAt(i) - 'a';
                if (cur.next[index] == null) { //没有就新建
                    cur.next[index] = new Node();
                }
                cur = cur.next[index];
                cur.path++; //经过这里
            }
            cur.end++;
        }

        //统计某个字符串的数量
        public int count(String word) {
            if (word == null)
                return 0;
            Node cur = root;
            int index = 0;
            for (int i = 0; i < word.length(); i++) {
                index = word.charAt(i) - 'a';
                if (cur.next[index] == null)
                    return 0;
                cur = cur.next[index];
            }
            return cur.end;
        }

        public boolean search(String word) {
            return count(word) > 0;
        }

        // 求前缀是prefix的数量
        public int prefixNum(String prefix) {
            if (prefix == null)
                return 0;
            Node cur = root;
            int index = 0;
            for (int i = 0; i < prefix.length(); i++) {
                index = prefix.charAt(i) - 'a';
                if (cur.next[index] == null)
                    return 0;
                cur = cur.next[index];
            }
            return cur.path; //返回这个经过的　　也就是以这个为前驱的
        }

        public boolean startsWith(String prefix) {
            return prefixNum(prefix) > 0;
        }

        // 在trie中删除word
        public void remove(String word) {
            if (word == null)
                return;
            if (!search(word)) //不包含这个字符串
                return;
            Node cur = root;
            int index = 0;
            for (int i = 0; i < word.length(); i++) {
                index = word.charAt(i) - 'a';
                if (--cur.next[index].path == 0) {
                    cur.next[index] = null; //释放掉下面的这棵树
                    return;
                }
                cur = cur.next[index];
            }
            cur.end--; //最后这个字符串也要--
        }
    }

    public static void main(String[] args) {

        // 简单测试

        Trie trie = new Trie();

        trie.insert("abc");
        trie.insert("ab");
        trie.insert("ab");
        trie.insert("abd");
        trie.insert("bc");
        trie.insert("bd");
        trie.insert("cd");
        trie.insert("cde");
        trie.insert("ce");

        System.out.println(trie.count("ab"));
        trie.remove("ab");
        System.out.println(trie.count("ab"));

        System.out.println(trie.count("abd"));
        trie.remove("ab");
        System.out.println(trie.count("ab"));
        System.out.println(trie.count("abd"));

        trie.remove("abd");
        System.out.println(trie.count("abd"));
    }
}
/**
 * 单调栈: 寻找一个数组中每一个元素　左右两边离它arr[i]最近的比它大的数
 * 栈底到栈顶: 由大到小 (也可以自定义从小到大)
 */
class MonotoneStack {

    static PrintStream out = System.out;

    public static void main(String[] args) {

        int[] arr = {3, 4, 5, 1, 2};
        int n = arr.length;

        /**--------------找左边的第一个比arr[i]大的-------------------*/
        int[] LL = new int[n]; //LL[i]存的是左边第一个比arr[i]大的数的下标
        Stack<Integer> stack = new Stack<>();
        for(int i = 0; i < n; i++){
            while(!stack.isEmpty() && arr[i] > arr[stack.peek()]){
                int top = stack.pop();
                if(stack.isEmpty()){
                    LL[top] = -1; //左边没有比arr[i]大的数
                }else {
                    LL[top] = stack.peek();
                }
            }
            stack.push(i); //注意是下标入栈
        }

        // 如果栈不空 //处理剩下的
        while(!stack.isEmpty()){
            int top = stack.pop();
            if(stack.isEmpty()) LL[top] = -1;
            else LL[top] = stack.peek();
        }

        for(int i = 0; i < n; i++) out.print(LL[i] + " "); // -1 -1 -1 2 2
        out.println();

        /**--------------找右边的第一个比arr[i]大的-------------------*/

        int[] RR = new int[n];//RR[i]存的是右边边第一个比arr[i]大的数的下标
        stack = new Stack<>();

        // 反过来即可
        for(int i = n-1; i >= 0; i--){
            while(!stack.isEmpty() && arr[i] > arr[stack.peek()]){
                int top = stack.pop();
                if(stack.isEmpty()){
                    RR[top] = -1; //左边没有比arr[i]大的数
                }else {
                    RR[top] = stack.peek();
                }
            }
            stack.push(i); //注意是下标入栈
        }

        // 如果栈不空, 处理剩下的
        while(!stack.isEmpty()){
            int top = stack.pop();
            if(stack.isEmpty()) RR[top] = -1;
            else RR[top] = stack.peek();
        }

        for(int i = 0; i < n; i++) out.print(RR[i] + " "); // 输出 1 2 -1 4 -1
        out.println();
    }
}
/**
 * 单调队列: 用来求出在数组的某个区间范围内求出最大值
 * 最经典的问题: 滑动窗口的最大值:
 * 题目链接: https://www.lintcode.com/problem/sliding-window-maximum/description
 *
 * 给出一个可能包含重复的整数数组，和一个大小为 k 的滑动窗口, 从左到右在数组中滑动这个窗口，找到数组中每个窗口内的最大值。
 *
 * 输入:
 * [1,2,7,7,8]
 * 3
 * 输出:
 * [7,7,8]
 *
 * 解释：
 * 最开始，窗口的状态如下：`[|1, 2 ,7| ,7 , 8]`, 最大值为 `7`;
 * 然后窗口向右移动一位：`[1, |2, 7, 7|, 8]`, 最大值为 `7`;
 * 最后窗口再向右移动一位：`[1, 2, |7, 7, 8|]`, 最大值为 `8`.
 *
 */
class MonotoneQueue {

    static PrintStream out = System.out;

    //单调双向队列(窗口内最大值), 某一时刻窗口内的最大值是对头 arr[queue.peekFirst()]
    public ArrayList<Integer> maxSlidingWindow(int[] nums, int k) {
        if (nums == null || k < 1 || nums.length < k)
            return null;
        ArrayList<Integer> res = new ArrayList<>();
        LinkedList<Integer> queue = new LinkedList<>();//保存的是下标
        for (int i = 0; i < nums.length; i++) {
            while (!queue.isEmpty() && nums[queue.peekLast()] <= nums[i]) //要队尾满足条件
                queue.pollLast();
            queue.addLast(i); // 注意添加的是下标
            if (i - k == queue.peekFirst())
                queue.pollFirst();//向左弹出过期的数据
            if (i >= k - 1) // 达到了k个数，这个窗口内的最大值是队列的头部
                res.add(nums[queue.peekFirst()]);
        }
        return res;
    }

    public static void main(String[] args) {

        int[] arr = {1, 2, 7, 7, 8};
        out.println(new MonotoneQueue().maxSlidingWindow(arr, 3)); // 7, 7, 8
    }
}

/**
 * 乘法和乘方快速幂
 * 题目链接:  http://xyoj.xynu.edu.cn/problem.php?id=1872&csrf=mmofuzhUWGip3c6WlmhiFY6bLxeVHZta
 */
class QuickPow {
    //递归 计算 (a^n) % mod
    static long pow_mod(long a, long n, long mod) {
        if (n == 0)      // a^0 = 1
            return 1;
        // 先求一半的 --> 你先给我求出 a ^ (n/2) 的结果给我
        long halfRes = pow_mod(a, n >> 1, mod); // n >> 1 --> n/2

        long res = halfRes * halfRes % mod;

        if ((n & 1) != 0)       // odd num
            res = res * a % mod;
        return res;
    }

    //非递归 计算 (a^n) % mod
    static long pow_mod2(long a, long n, long mod) {
        long res = 1;
        while (n > 0) {
            if ((n & 1) != 0) // 二进制最低位 是 1 --> (n&1) != 0  -->  乘上 x ^ (2^i)   (i从0开始)
                res = res * a % mod;
            a = a * a % mod;  // a = a^2
            n >>= 1;          // n -> n/2      往右边移一位
        }
        return res;
    }

    // 计算 (a * b) % mod
    static long mul_mod(long a, long b, long mod) {
        long res = 0;
        while (b > 0) {
            if ((b & 1) != 0)  // 二进制最低位是1 --> 加上 a的 2^i 倍, 快速幂是乘上a的2^i ）
                res = (res + a) % mod;
            a = (a << 1) % mod;    // a = a * 2    a随着b中二进制位数而扩大 每次 扩大两倍。
            b >>= 1;               // b -> b/2     右移  去掉最后一位 因为当前最后一位我们用完了，
        }
        return res;
    }

    //非递归 计算 (a^n) % mod   配合 mul
    static long pow_mod3(long a, long n, long mod) {
        long res = 1;
        while (n > 0) {
            if ((n & 1) != 0) // 二进制最低位 是 1 --> (n&1) != 0  -->  乘上 x ^ (2^i)   (i从0开始)
                res = mul_mod(res, a, mod) % mod;
            a = mul_mod(a, a, mod) % mod;  // a = a^2
            n >>= 1;          // n -> n/2      往右边移一位
        }
        return res;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedInputStream(System.in));
        int T = in.nextInt();
        while (T-- > 0) {
            int a = in.nextInt();
            int n = in.nextInt();
            int mod = in.nextInt();
//            System.out.println(pow_mod(a,n,mod));
//            System.out.println(pow_mod2(a,n,mod));
            System.out.println(pow_mod3(a, n, mod));
        }
    }
}

/**
 * 题目:http://poj.org/problem?id=3070
 * 经典的斐波那契数列问题 f[n] = f[n-1] + f[n-2]
 */
class MatrixQuickPow {

    static class Matrix {
        public int row;
        public int col;
        public int[][] m;

        public Matrix(int row, int col) {
            this.row = row;
            this.col = col;
            m = new int[row][col];
        }
    }

    static final int MOD = 10000;

    static Matrix mul(Matrix a, Matrix b) {
        Matrix c = new Matrix(a.row, b.col); //注意这里

        for (int i = 0; i < a.row; i++) {
            for (int j = 0; j < b.col; j++) {
                for (int k = 0; k < a.col; k++)
                    c.m[i][j] = (c.m[i][j] + a.m[i][k] * b.m[k][j]) % MOD;
            }
        }
        return c;
    }

    static Matrix pow(Matrix a, int k) {
        Matrix res = new Matrix(a.row, a.col); // 方阵
        for (int i = 0; i < a.row; i++)
            res.m[i][i] = 1;
        while (k > 0) {
            if ((k & 1) != 0)
                res = mul(res, a);
            a = mul(a, a);
            k >>= 1;
        }
        return res;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedInputStream(System.in));

        while (in.hasNext()) {
            int n = in.nextInt();
            if (n == -1) break;
            if (n == 0) {
                System.out.println(0);
                continue;
            }

            Matrix matrix = new Matrix(2, 2);
            matrix.m[0][0] = matrix.m[0][1] = matrix.m[1][0] = 1;
            matrix.m[1][1] = 0;

            Matrix res = pow(matrix, n - 1);

            System.out.println(res.m[0][0] % MOD);
        }
    }
}
```

