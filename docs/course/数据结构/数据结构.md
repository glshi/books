 

## 第一章    绪论

**1.1**  **定义**

**1.**     **数据**

数据是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并且被计算机程序处理的符号的总称。

**2.**     **数据元素**

数据元素是数据的基本单位，在计算机程序中通常将其作为一个整体进行考虑和处理。数据元素可由若干数据项组成。

**3.**     **数据项**

数据项是数据结构中讨论的最小单位，是数据记录中最基本的、不可分的数据单位。

**4.**     **数据对象**

数据对象是性质相同的数据元素的集合，是数据的一个子集。

**5.**     **数据结构**

数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。它包含逻辑结构、存储结构和对数据的运算3方面的内容。

**6.**     **数据的逻辑结构**

数据的逻辑结构是对数据之间关系的描述，它与数据的存储结构无关，同一种逻辑结构可以有多种存储结构。主要有线性结构和非线性结构两大类。

**7.**     **数据的物理结构**

数据的物理结构又称为存储结构，是数据的逻辑结构在计算机中的表示(又称映象)。

4种存储方法：顺序存储方法、链式存储方法、索引存储方法和散列存储方法。

**8.**     **数据类型和变量**

数据类型是一个值的集合以及定义在这个值集上的一组操作。

变量是用来存储值的所在处，它们有名字和数据类型。

**1.2**  **算法**

**1.**     **定义**

算法可以理解为由基本运算及规定的运算顺序所构成的完整的解题步骤，或者看成按照要求设计好的有限的确切的计算序列。

**2.**     **算法特性**

算法包含有穷性、确定性、输入、输出和可行性5个特性。

**3.**     **算法的设计目标**

算法设计目标包括正确性、可读性、健壮性和算法效率4个方面。

**4.**     **时间复杂度**

时间复杂度是算法的时间度量，同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。

**5.**     **空间复杂度**

空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。

## 第二章    线性表

**1.**     **线性表的定义**

线性表是具有相同特性数据元素的一个有限序列。

**2.**     **线性表的存储结构**

​     线性表的存储结构有**顺序存储结构**和**链式存储结构**两种

​     顺序存储结构：

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg)

​     链式存储结构：单链表、双链表、循环单链表、循环単链表、循环双链表和静态链表。

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg)

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image006.jpg)

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image008.jpg)

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image010.jpg)

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image012.jpg)

 

**3.**     **线性表的存储特性**

**(1)**    **顺序存储结构特性**

- 随机访问特性

- 占用连续的存储空间

- 静态分配

- 插入删除操作需要移动多个元素


**(2)**    **链式存储结构特性**

- 不支持随机访问

- 结点的存储空间利用率较之顺序表稍低一些

- 动态分配

- 插入删除操作不需要移动元素


**4.**     **线性表的结构定义**

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image014.jpg)

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image016.jpg)

**5.**     **线性表的基本操作**

**1.1**   **顺序表**

(1)    初始化顺序表

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image018.jpg)

(2)    求指定位置元素

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image020.jpg)

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image022.jpg)

(3)    查找元素下表

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image024.jpg)

(4)    插入元素

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image026.jpg)

(5)    删除元素

 ![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image028.jpg)

**1.2**   **单链表**

(1)  初始化单链表

 ![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image030.jpg)

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image032.jpg)

(2)  求指定位置元素

 ![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image034.jpg)

​     

(4)  插入元素

 ![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image036.jpg)

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image038.jpg)

(5)  删除元素

 ![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image040.jpg)

 ![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image042.jpg)

 

**1.3**   **双链表**

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image044.jpg)![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image046.jpg)

 

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image048.jpg)

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image050.jpg)

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image052.jpg)

## 第三章    栈、队列和数组

**1.**     **栈和队列的基本概念**

**1.1**   **栈**

(1)    栈的定义

栈是一种只能在一端进行插入或者删除的线性表。

(2)    栈的特点

先进后出

(3)    栈的存储结构

顺序栈和链式栈。

**1.2**   **队**

(1)    队列的定义

一种操作受限的线性表，只能在一端插入，另一端删除。

(2)    队列的特点

先进先出。

(3)    队列的存储结构

顺序队和链队。

**2.**     **栈和队列的数据结构**

**1.1**   **栈**

(1)    顺序栈定义

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image054.jpg)

(2)    链栈的定义

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image056.jpg)

**1.2**   **队**

(1)    顺序队定义

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image058.jpg)![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image060.jpg)

(2)    链队的定义

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image062.jpg)

**3.**     **栈和队列的基本算法操作**

**1.1**   **顺序栈的算法操作**

(1)    顺序栈要素

两个状态：

栈空：st.top==-1 ；栈满：st.top==masSize-1。

两个操作

进栈：++(st.top);st.data[st.top]=x; 。出栈：x=st.data[st.top];--(st.top); 。

(2)    顺序栈算法

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image064.jpg)

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image066.jpg)

**1.2**   **链栈的算法操作**

栈空：lst -> next == null；栈满：不存在栈满，以内存大小为限制。

进栈：++(st.top);st.data[st.top]=x; 。出栈：x=st.data[st.top];--(st.top);

​      ![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image068.jpg)

 ![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image070.jpg) ![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image072.jpg) ![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image074.jpg)

**1.3**   **顺序队的算法操作**

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image076.jpg) ![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image078.jpg) ![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image080.jpg)

 

**1.4**   **链队的算法操作**

 

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image082.jpg) ![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image084.jpg)

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image086.jpg) ![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image088.jpg)

## 第四章    串

**1.**     **串的定义**

串是由零个或者多个字符组成的有限序列。串中字符的个数称为串的长度，含有零个元素的串称为空串。空格串不等于空串。

**2.**     **串的结构定义**

**定长存储表示**

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image090.jpg)

**变长存储表示**

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image092.jpg)

 

**3.**     **串的常见函数**

 

**4.**     **串的模式匹配算法**

**1.1**   **简单模式匹配算法**

Brute-Force算法的基本思想是：

1) 从目标串s 的第一个字符起和模式串t的第一个字符进行比较，若相等，则继续逐个比较后续字符，否则从串s 的第二个字符起再重新和串t进行比较。

2) 依此类推，直至串t 中的每个字符依次和串s的一个连续的字符序列相等，则称模式匹配成功，此时串t的第一个字符在串s 中的位置就是t 在s中的位置，否则模式匹配不成功。

 

**1.2**   **KMP****算法**

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image094.jpg)![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image096.jpg)![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image098.jpg)![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image100.jpg)![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image102.jpg)![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image104.jpg)![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image106.jpg)

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image108.jpg)

 

**next****数组的含义就是一个固定字符串的最长前缀和最长后缀相同的长度。**

**模式匹配串是：****ababaca****，****next****数组的值是****[-1,-1,0,1,2,-1,0]****。**

 

ababaca，长度是7，所以next[0]，next[1]，next[2]，next[3]，next[4]，next[5]，next[6]分别计算的是a，ab，aba，abab，ababa，ababac，ababaca的相同的最长前缀和最长后缀的长度。由于a，ab，aba，abab，ababa，ababac，ababaca的相同的最长前缀和最长后缀是“”，“”，“a”，“ab”，“aba”，“”，“a”,所以next数组的值是[-1,-1,0,1,2,-1,0]，这里-1表示不存在，0表示存在长度为1，2表示存在长度为3。这是为了和代码相对应

**注意最长前缀：是说以第一个字符开始，但是不包含最后一个字符。

 

[ｎｅｘｔ数组求解说明](http://blog.csdn.net/starstar1992/article/details/54913261)

 

 

 



 

## 第五章    数组、稀疏矩阵和广义表

**1.**     **数组的结构定义**

二维数组是一个矩阵。

**2.**     **稀疏矩阵的定义**

当尺寸为mXn的矩阵中有k个非零元素时，若k<<mXn，则称A为稀疏矩阵。

在[矩阵](https://baike.baidu.com/item/矩阵)中，若数值为0的元素数目远远多于非0元素的数目，并且非0元素分布没有规律时，则称该矩阵为稀疏矩阵。

**3.**     **稀疏矩阵的顺序存储**

**1.1**   **三元组表示法**

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image110.jpg)

**1.2**   **伪地址表示法**

伪地址表示法和三元组表示相似，只是三元组每一行有两个存储单元存放地址，而伪地址法只需要一个。一个用来存储矩阵元素值，另一个用来存放伪地址。

一个mXn的稀疏矩阵A中元素A[i][j]的伪地址计算方法为n(i-1)+j。显然，用伪地址整除以n可以得到i的值，用伪地址对n取余可得到j的值。

**4.**     **稀疏矩阵的链式存储**

**1.1**   **邻接表**

参照图的邻接表表示法。

**1.2**   **十字链表**

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image112.jpg)

**5.**     **广义表**

 

广义表的长度：表中最上层元素的个数。

广义表的深度：表中括号的最大层数。

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image114.jpg)



 

## 第六章    树和二叉树

**1.**     **树及有关概念** 

**节点的度**：一个节点含有的子树的个数称为该节点的度；

**叶节点或终端节点**：度为0的节点称为叶节点；

**非终端节点或分支节点**：度不为0的节点；

**双亲节点或父节点：**若一个节点含有子节点，则这个节点称为其子节点的父节点；

**孩子节点或子节点：**一个节点含有的子树的根节点称为该节点的子节点；

**兄弟节点：**具有相同父节点的节点互称为兄弟节点；

**树的度：**一棵树中，最大的节点的度称为树的度；

**节点的层次：**从根开始定义起，根为第1层，根的子节点为第2层，以此类推；

**树的高度或深度：**树中节点的最大层次；

**堂兄弟节点：**双亲在同一层的节点互为堂兄弟；

**节点的祖先：**从根到该节点所经分支上的所有节点；

**子孙：**以某节点为根的子树中任一节点都称为该节点的子孙。

**森林：**由m（m>=0）棵互不相交的树的集合称为森林； 

**2.**    **二叉树** 

a)     二叉树（二叉树与度为2的树不同，二叉树的度可能是0，1，2）；左孩子，右孩子。二叉树的五种基本形态。

b)     满二叉树：深度为k，有2k-1个结点。 

c)     完全二叉树：给满二叉树的结点编号，从上至下，从左至右，n个结点的完全二叉树中结点在对应满二叉树中的编号正好是从1到n。

**3.**    **二叉树的性质** 

a)     在非空二叉树的i层上，至多有2i-1个节点(i>=1)。通过归纳法论证。

b)     在深度为K的二叉树上最多有2k-1个结点（k>=1)。通过归纳法论证。

c)     对于任何一棵非空的二叉树,如果叶节点个数为n0，度数为2的节点个数为n2，则有: n0 = n2 + 1

d)     在一棵二叉树中，除了叶子结点（度为0）之外，就剩下度为2(n2)和1(n1)的结点了。则树的结点总数为T = n0+n1+n2;

e)     在二叉树中结点总数为T，而连线数为T-1.所以有：n0+n1+n2-1 = 2*n2 +n1;最后得到n0 = n2+1;    

**4.**    **二叉树的存储结构** 

**(1)**    **顺序存储结构** 

用数组、编号i的结点存放在[i-1]处。适合于存储完全二叉树。 

**(2)**    **链式存储结构** 

typedef struct BTNode

 { 

 DataType data; 

​               struct BTNode *lchild, *rchild; 

} BTNode; 

**5.**    **遍历二叉树** 

常见有四种遍历方式 ：按层次遍历，先序遍历，中序遍历，后序遍历。 

按层次遍历：“从上至下，从左至右”，利用队列。 

先序遍历：DLR；中序遍历：LDR；后序遍历LRD。

**6.**    **线索二叉树** 

**1.1**   **线索** 

n个结点的二叉链表中有n+1个空指针，可以利用其指向前驱或后继结点，叫线索，同时需附加一个标志，区分是子树还是线索。 

lchild 有左子树，则指向左子树，标志ltag == 0； 没有左子树，可作为前驱线索，标志ltag == 1。 rchild 有右子树，则指向右子树，标志rtag == 0； 没有右子树，可作为后继线索，标志rtag == 1。

**1.2**   **线索化二叉树** 

利用空指针作为线索指向前驱或后继。左边空指针可以作为前驱线索，右边空指针可以作为后继线索，可以全线索化或部分线索化。

**7.**    **树和森林** 

**1.1**   **树的存储结构** 

双亲表示法，孩子表示法，孩子兄弟表示法。 

(1)    双亲表示法容易求得双亲，但不容易求得孩子；

(2)    孩子表示法容易求得孩子，但求双亲麻烦；

(3)    两者可以结合起来使用。孩子兄弟表示法，容易求得孩子和兄弟，求双亲麻烦，也可以增加指向双亲的指针来解决。 

1.2   **森林的存储结构**

孩子兄弟存储结构可以方便的实现树或森林于二叉树的转换。

1.3   **树与二叉树的转换** 

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image116.jpg)

1.4    **森林与二叉树的转换**

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image118.jpg)

1.5   树和森林的遍历

(1)    树的遍历

树的遍历有两种方式：先序遍历和后序遍历。

树的先序遍历对应二叉树的先序遍历，树的后序遍历对应二叉树的中序遍历。

(2)    森林的遍历

森林的遍历方式有两种：先序遍历和中序遍历。

森林的先序遍历对应二叉树的先序遍历，森林的中序遍历对应二叉树的中序遍历。

**8.**    **赫夫曼树及其应用** 

**1.1**   **最优二叉树(****赫夫曼树，哈夫曼树)** 

树的带权路径长度：所有叶子结点的带权路径长度之和。 

带权路径长度最小的二叉树称为最优二叉树，或赫夫曼树(哈夫曼树)。 

**1.2**   **构造赫夫曼树** 

(1)    将所有左，右子树都为空的作为根节点。

(2)    在森林中选出两棵根节点的权值最小的树作为一棵新树的左，右子树，且置新树的附加根节点的权值为其左，右子树上根节点的权值之和。注意，左子树的权值应小于右子树的权值。

(3)    从森林中删除这两棵树，同时把新树加入到森林中。

(4)    重复2，3步骤，直到森林中只有一棵树为止，此树便是哈夫曼树。

**1.3**   **赫夫曼编码(****前缀码)** 

向左分支为0，向右分支为1，从根到叶子的路径构成叶子的前缀编码。

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image120.jpg)

**记住，设计电文总长最短的二进制前缀编码，就是以****n****个字符出现的频率作为权构造一棵哈夫曼树，由哈夫曼树求得的编码就是哈夫曼编码。**

 

 

 



 

## 第七章    图

**1.**     **图的基本概念**

**(1)**    **图**

图由结点的有穷集合V和边的集合E组成。

**(2)**    **有向图和无向图**

a)     边有方向称之为**有向图**，无方向称之为**无向图**。

b)     若有向图中有n个顶点，则最多有n(n-1)条边，将具有n(n-1)条边的有向图称为**有向完全图。**

c)     若无向图中有n个顶点，则最多有n(n-1)/2条边，将具有n(n-1)/2条边的无向图称为**无向完全图。**

**(3)**    **顶点的度、入度和出度**

与顶点相关的边的条数称为顶点的**度**。**有向图的度等于入度和出度之和**。

**(4)**    **路径和路径长度**

**路径**指相邻顶点序偶所构成的序列。**路径长度**指路径上边的数目。

**(5)**    **连通、连通图和连通分量**

a)     在无向图中，如果顶点Vi到顶点Vj有路径，则称Vi和Vj**连通**。如果图中任意两个顶点之间都连通，则称该图为**连通图**；否则，将其中的极大连通子图称为**连通分量**。

b)     在有向图中，如果顶点Vi到顶点Vj有路径，则称Vi和Vj**连通**。如果图中每一对顶点Vi和Vj，从Vi到Vj和从Vj到Vi都有路径，则称该图为**强连通图**；否则，将其中的极大强连通子图称为**强连通分量**。

**(6)**    **权和网**

图中每条边都可以有一个对应的数，这种和边相关的数称为**权。**

边上带有权的图称为**带权图，**也称为**网。**

**2.**     **图的存储结构**

**(1)**    **邻接矩阵**

1)     邻接矩阵是图的**顺序存储结构**。

2)     对于无向图，邻接矩阵是对称的。矩阵中第i行或第i列元素之和即为顶点i的**度**。

矩阵中“1”的个数为图的总边数的2倍。

3)     对于有向图，矩阵中第i行元素之和为顶点i的**出度**，第j列元素之和为顶点j的**入度**。

矩阵中“1”的个数等于图的边数。

 

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image122.jpg)

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image124.jpg)

**(2)**    **邻接表**

a)     邻接表是图的一种**链式存储结构**。

b)     邻接表用数组存储每个节点

c)     数组中的每个节点的所有邻接点组成一个链表(因为邻接点的个数不确定)。这个邻接表就是顶点的出度表

d)     邻接表关心了出度，但是查找入度就需要遍历整个图

无向图的邻接表如下：

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image126.jpg) 

 

有向图的邻接表和逆邻接表如下：

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image128.jpg)

**(3)**    **邻接多重表**

邻接多重表和十字链表类似。

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image130.jpg)

**3.**     **图的遍历算法**

**(1)**    **深度优先遍历**

图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似。

​     

它的思想：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，**则依次退回到最近被访问过的顶点**，重复上述过程，直至图中所有顶点都被访问到为止。

 

显然，深度优先搜索是一个递归的过程。

**(2)**    **广度优先遍历**

广度优先搜索算法(Breadth First Search)，又称为"宽度优先搜索"或"横向优先搜索"，简称BFS。

 

它的思想是：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。

 

换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2...的顶点。

**4.**     **最小生成树**

(1)    **最小生成树的概念**

a)     一个带权值的图：网。所谓最小成本，就是用n-1条边把n个顶点连接起来，且连接起来的权值最小。

b)     我们把构造联通网的最小代价生成树称为最小生成树。

c)     普里姆算法和克鲁斯卡尔算法都是针对无向图的。

d)     普里姆算法适用于稠密图，克鲁斯卡尔算法适用于稀疏图。

e)     所有边权值都不相等，最小生成树唯一，或者有相等的边，但是在构造最小生产树的过程中权值相等的边都被并入生成树的图中，其最小生成树也是唯一的。

**(2)**    **普里姆算法**

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image132.jpg)

**(3)**    **克鲁斯卡尔算法**

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image134.jpg)

**5.**     **最短路径**

**(1)**    **迪杰斯特拉算法**

求出的是**某一顶点到其余各顶点的最短路径**。

**(2)**    **弗洛伊德算法**

求出的是任意一对顶点间的最短路径。

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image136.jpg)

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image138.jpg)

**6.**     **拓扑排序**

**(1)**    **AOV****网**

在一个表示工程的有向图中，有顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为AOV网。

AOV网中的弧表示活动之间存在的某种制约关系。

所谓拓扑排序，其实就是对一个有向图构造拓扑序列的过程。

**(2)**    **拓扑排序核心算法**

a)     从有向图中选取一个没有前驱的顶点（即入度为零的顶点），并输出之;

b)     从有向图中删去此顶点以及所有以它为尾的弧（即弧头顶点的入度减1）;

c)     重复上述两步,直到全部顶点均已输出，拓扑有序序列形成，拓扑排序完成；

d)     若图中还有未输出的顶点，但已跳出处理循环。这说明图中还剩下一些顶点，它们都有直接前驱，再也找不到没有前驱的顶点了。这时AOV网络中必定存在有向环。

e)     时间复杂度为O(n+e)。

**7.**     **关键路径**

(1)    AOE网

如果在无环的带权有向图中，用有向边表示一个工程中的活动，用边上权值表示活动持续时间，用顶点表示事件，则这样的有向图叫做用边表示活动的网络，简称AOE。

(2)    关键路径核心算法

在AOE网中，从源点到汇点的所有路径中，具有最大路径长度的路径称为关键路径。

关键路径是最长路径，也是整个工期所完成的最短时间。

## 第八章    排序

 

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image140.jpg)

**1.**     **排序的定义**

所谓排序，即将原来无序的一个序列重新排列成有序的序列。

**2.**     **排序的分类**

1.1   插入类的排序

(1)    直接插入排序

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image142.jpg)

(2)    折半插入排序

有序序列，在寻找插入位置时采用折半插入算法，其他和直插算法一样。

(3)    希尔排序

希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。

希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。

1.2   交换类排序

(1)    起泡排序

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image144.jpg)

(2)    快速排序

1)     选择一个基准元素,通常选择第一个元素或者最后一个元素,

2)     通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。

此时基准元素在其排好序后的正确位置

3)     然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。

1.3   选择类的排序

(1)    简单选择排序

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image146.jpg)

(2)    堆排序

建堆的过程即是堆排序的过程。堆是一颗完全二叉树。

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image148.jpg)

1.4   归并类的排序

二路归并排序

1.5   基数类的排序

基数排序

**3.**     **排序总结**

**1.1**   **复杂度总结**

O(1) < O(![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image150.png) < O(n) < O(n![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image150.png) < O(![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image152.png)) < O(![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image154.png)) < … < O(![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image156.png)) < O(![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image158.png))

**时间复杂度**：快速排序，希尔排序，归并排序和堆排序平均时间复杂度都是O(n![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image150.png)，其他都是O(![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image152.png))。快速排序最坏情况下是O(![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image152.png))。

​     速记口诀：快些归队

初始序列有序，起泡和直接插入排序是O(n)。

**空间复杂度**：快速排序为O(![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image150.png)，归并排序为O(n)，基数排序为O(![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image160.png))，其他都是O(1)。

​          O(n![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image150.png) O(![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image162.png)O(![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image152.png))  O(![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image154.png))  O(1) O(n) O(![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image164.png)) O(![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image160.png))  O(n)

**1.2**   **稳定性总结**

快速排序，希尔排序，选择排序和堆排序不稳定，其他都是稳定的。

速记口诀：快些选队

 

经过一趟排序，能够保证一个元素到达最终位置：快速，起泡，简单选择，堆。

排序方法的元素比较次数和原始序列无关：简单选择和折半插入。

排序方法的排序趟数和原始序列有关：交换类的排序。

​     

## 第九章    查找

**1.**     **查找定义**

给定一个值K，在含有n个记录的表中找出关键字等于K的记录。

用平均查找长度ASL（也成为平均比较次数）来衡量一个算法效率优劣的标准。

**2.**     **查找方法**

**1.1**   **顺序查找法**

从表的一端顺序开始，顺序扫描线性表。适用于顺序表和链表。

**1.2**   **折半查找法**

要求线性表是有序的，查找位置是中间位置（low+high）/ 2。

1 2 **3** 4 5 6  1 2 3 **4** 5 6 7 3和4是中间位置。

**1.3**   **分块查找法**

分块查找又称为索引顺序查找。数据元素按块分布，并且按照递增或者递减有序排列。

查找算法分两步：第一步采用二分查找，第二步采用顺序查找。

**3.**     **二叉排序树**

**1.1**   **二叉排序树定义**

又称[二叉查找树](https://baike.baidu.com/item/二叉查找树)（Binary Search Tree），亦称[二叉搜索树](https://baike.baidu.com/item/二叉搜索树)。

二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：

（1）若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值；

（2）若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；

（3）左、右子树也分别为二叉排序树；

1.2   **二叉排序树的查找**

 

**1.3**   **二叉排序树的插入**

首先执行查找算法，找出被插结点的父亲结点。

判断被插结点是其父亲结点的左、右儿子，将被插结点作为叶子结点插入。

若二叉树为空，则首先单独生成根结点。

注意：新插入的结点总是叶子结点。

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image166.jpg)

**1.4**   **二叉排序树的删除**

在二叉排序树删去一个结点，分三种情况讨论：

\1.    若*p结点为叶子结点，即PL(左子树)和PR(右子树)均为空树。由于删去叶子结点不破坏整棵树的结构，则可以直接删除此子结点。

\2.    若*p结点只有左子树PL或右子树PR，此时只要令PL或PR直接成为其双亲结点*f的左子树（当*p是左子树）或右子树（当*p是右子树）即可，作此修改也不破坏二叉排序树的特性。

\3.    若*p结点的左子树和右子树均不空。在删去*p之后，为保持其它元素之间的相对位置不变，可按中序遍历保持有序进行调整，可以有两种做法：

其一是令*p的左子树为*f的左/右(依*p是*f的左子树还是右子树而定)子树，*s为*p左子树的最右下的结点，而*p的右子树为*s的右子树；

其二是令*p的直接前驱（或直接后继）替代*p，然后再从二叉排序树中删去它的直接前驱（或直接后继）－即让*f的左子树(如果有的话)成为*p左子树的最左下结点(如果有的话)，再让*f成为*p的左右结点的父结点。

在二叉排序树上删除一个结点的算法如下：

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image168.jpg) ![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image170.jpg)

 

**4.**     **平衡二叉树**

**1.1**   **平衡二叉树的定义**

**平衡二叉树**（Self-balancing binary search tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树，同时，平衡二叉树必定是二叉搜索树，反之则不一定。平衡二叉树的常用实现方法有[红黑树](https://baike.baidu.com/item/红黑树)、[AVL](https://baike.baidu.com/item/AVL/7543015)、[替罪羊树](https://baike.baidu.com/item/替罪羊树)、[Treap](https://baike.baidu.com/item/Treap)、[伸展树](https://baike.baidu.com/item/伸展树)等。 

**平衡因子**：左子树的高度减去右子树的高度。由平衡二叉树的定义可知，平衡因子的取值只可能为0,1,-1.分别对应着左右子树等高，左子树比较高，右子树比较高。

**平衡旋转：****LL****、****LR****、****RL****、****RR****。**

**1.2**   **平衡二叉树的插入**

 

**1.3**   **平衡二叉树的删除**

 

**5.**     **B-树**

**1.1**   **B-树定义**

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image172.jpg)

**1.2**   **B-树概念**

M为树的[阶数](https://baike.baidu.com/item/阶数)，B-树或为空树，否则满足下列条件：

1.定义任意非[叶子结点](https://baike.baidu.com/item/叶子结点)最多只有M个儿子；且M>2；

2.[根结点](https://baike.baidu.com/item/根结点)的儿子数为[2, M]；

3.除根结点以外的非叶子结点的儿子数为[M/2, M]；

4.每个结点存放至少M/2-1（取上整）和至多M-1个[关键字](https://baike.baidu.com/item/关键字)；（至少2个关键字,根[节点](https://baike.baidu.com/item/节点)至少一个关键字）；

5.非叶子结点的关键字个数=指向儿子的[指针](https://baike.baidu.com/item/指针)个数-1；

6.非叶子结点的关键字：K[1], K[2], …, K[m-1]，m<M+1；且K*[i]< K[i+1]* *；*

7.非叶子结点的指针：P[1], P[2], …, P[m]；其中P[1]指向[关键字](https://baike.baidu.com/item/关键字)小于K[1]的子树，P[m]指向关键字大于K[m-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；

8.所有[叶子结点](https://baike.baidu.com/item/叶子结点)位于同一层；

如：（M=3）

[![M=3的B-树](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image173.jpg)](https://baike.baidu.com/pic/B-树/1975968/0/ac754782818df7f70cf4d2b4?fr=lemma&ct=single)M=3的B-树

B-树的搜索，从[根结点](https://baike.baidu.com/item/根结点)开始，对结点内的关键字（有序）序列进行[二分查找](https://baike.baidu.com/item/二分查找)，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子[指针](https://baike.baidu.com/item/指针)为空，或已经是[叶子结点](https://baike.baidu.com/item/叶子结点)。

 

[**B-tree**](https://baike.baidu.com/item/B-tree/6606402)**树即**[**B树**](https://baike.baidu.com/item/B树/5411672)，B即Balanced，平衡的意思。因为B树的原英文名称为B-tree，而国内很多人喜欢把B-tree译作B-树，其实，这是个非常不好的直译，很容易让人产生[误解](https://baike.baidu.com/item/误解/8094198)。如[人们](https://baike.baidu.com/item/人们)可能会以为B-树是一种树，而B树又是另一种树。而事实上是，**B-tree**就是指的**B树**。

**1.3**   **B-树特性**

1.[关键字](https://baike.baidu.com/item/关键字)集合分布在整颗树中；

2.任何一个关键字出现且只出现在一个结点中；

3.搜索有可能在非[叶子结点](https://baike.baidu.com/item/叶子结点)结束；

4.其搜索性能[等价](https://baike.baidu.com/item/等价)于在关键字全集内做一次[二分查找](https://baike.baidu.com/item/二分查找)；

5.自动层次控制；

由于限制了除[根结点](https://baike.baidu.com/item/根结点)以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率，其最底搜索性能为：

其中，M为设定的非叶子结点最多子树个数，N为关键字总数；

所以B-树的性能总是等价于二分查找（与M值无关），**没有**[**B树**](https://baike.baidu.com/item/B树)**平衡的问题；**

由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占M/2的结点；删除结点时，需将两个不足M/2的兄弟[节点](https://baike.baidu.com/item/节点)合并.

**6.**     **B+树**

**B+** **树**是一种树数据结构，是一个n叉排序树，每个节点通常有多个孩子，一棵B+树包含根节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个[包含](https://baike.baidu.com/item/包含)两个或两个以上孩子节点的节点。

B+ 树通常用于数据库和操作系统的[文件系统](https://baike.baidu.com/item/文件系统)中。NTFS, ReiserFS, NSS, XFS, JFS, ReFS 和BFS等文件系统都在使用B+树作为元数据索引。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入。

![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image175.jpg)

一棵m阶的B+树和m阶的B树的异同点在于：

·      所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。(而B 树的叶子节点并没有包括全部需要查找的信息)

·      所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。(而B 树的非终节点也包含需要查找的有效信息)

**7.**     **散列表**

**1.**     **散列表定义**

[散列表](https://baike.baidu.com/item/散列表)（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的[数据结构](https://baike.baidu.com/item/数据结构)。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做[散列函数](https://baike.baidu.com/item/散列函数)，存放记录的[数组](https://baike.baidu.com/item/数组)叫做[散列表](https://baike.baidu.com/item/散列表)。

**2.**     **散列表的构造方法**

**1.** [**直接寻址**](https://baike.baidu.com/item/直接寻址)**法**

取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a·key + b，其中a和b为常数（这种[散列函数](https://baike.baidu.com/item/散列函数)叫做自身函数）。若其中H(key）中已经有值了，就往下一个找，直到H(key）中没有值了，就放进去。

**2.** **数字分析法**

分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。

**3.** **平方取中法**

当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址。

**5.** **随机数法**

选择一[随机函数](https://baike.baidu.com/item/随机函数)，取关键字的随机值作为散列地址，通常用于关键字长度不同的场合。

**6.** **除留余数法**

取关键字被某个不大于[散列表](https://baike.baidu.com/item/散列表)表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p,p<=m。不仅可以对[关键字](https://baike.baidu.com/item/关键字)直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生同义词。

**3.**     **散列表的冲突处理方法**

**1.1**   **开发定址法**

**(1)**    **线性探查法**

线性探查法是从发生冲突的地址(设为d)开始，依次探查d的下一个地址，直到找到一个空位置为止。

线性探查法容易产生**堆积问题**。

**(2)**    **平方探查法**

设发生冲突的地址为d，用平方探查法所得到的新的地址序列为d+![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image177.png)，d-![img](file:///C:/Users/glshi/AppData/Local/Temp/msohtmlclip1/01/clip_image179.png)

平方探查法可以减少堆积问题，但是不能探查到表上的所有单元，但至少能探查到一半的单元。

**(3)**    **为随机数法和双Hash****函数法H(H(key))**

**1.2**   **链地址法**

又称拉链法，即把所有的同义词用单链表连接起来的方法。

**4.**     **散列表的性能**

影响产生冲突多少的因素，也就是影响查找效率的因素。影响产生冲突多少有以下三个因素：

1. [散列函数](https://baike.baidu.com/item/散列函数)是否均匀；

2. 处理冲突的方法；

3. [散列表](https://baike.baidu.com/item/散列表)的装填因子。

[散列表](https://baike.baidu.com/item/散列表)的装填因子定义为：α= 填入表中的元素个数 / 散列表的长度

α是[散列表](https://baike.baidu.com/item/散列表)装满程度的标志因子。由于表长是定值，α与“填入表中的元素个数”成正比，所以，α越大，填入表中的元素较多，产生冲突的可能性就越大；α越小，填入表中的元素较少，产生冲突的可能性就越小。

**5.**     **散列表的查找**

(1)    首先根据**散列表的构造方法**找到**散列地址**；

(2)    再根据对应的**冲突解决方法**依次比较**此散列地址上的多个值**，相等即查到，比较到末尾时都不相等，即不存在该记录。

 